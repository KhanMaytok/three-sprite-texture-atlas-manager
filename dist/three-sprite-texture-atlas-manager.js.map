{"version":3,"sources":["three-sprite-texture-atlas-manager.js","src/knapsack-rectangle.js","src/knapsack-node.js","src/knapsack.js","src/texture-manager.js","src/three-sprite-texture-atlas-manager.js"],"names":[],"mappings":"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","file":"three-sprite-texture-atlas-manager.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.threeSpriteAtlasTextureManager = factory()\n}(this, function () { 'use strict';\n\n  /*\n   * Helper classes to generate a texture map for sprites of various sizes.\n   *\n   * Simple class to describe a rectangular area witin the knapsack.\n   */\n\n  class KnapsackRectangle {\n    constructor( left, top, right, bottom ) {\n      this.left   = Math.floor( ( typeof left   === 'number' && isFinite( left   ) ) ? left   : 0 );\n      this.top    = Math.floor( ( typeof top    === 'number' && isFinite( top    ) ) ? top    : 0 );\n      this.right  = Math.floor( ( typeof right  === 'number' && isFinite( right  ) ) ? right  : 0 );\n      this.bottom = Math.floor( ( typeof bottom === 'number' && isFinite( bottom ) ) ? bottom : 0 );\n    }\n\n    get Xcentre () { return Math.floor( ( ( this.right - this.left ) / 2 ) + this.left ) - 0.5; }\n    get Ycentre () { return Math.floor( ( ( this.bottom - this.top ) / 2 ) + this.top  ) - 0.5; }\n    get width ()  { return ( this.right - this.left ); }\n    get height () { return ( this.bottom - this.top ); }\n  }\n\n  /*\n   * Represents a single texture \"node\" within a larger texture atlas.\n   *\n   * Based on: http://www.blackpawn.com/texts/lightmaps/default.html\n   */\n\n  class KnapsackNode {\n    constructor( knapsack ) {\n      this.knapsack = knapsack;\n      this.leftChild = null;\n      this.rightChild = null;\n      this.rectangle = null;\n      this.imageID = null;\n      this._texture = null;\n\n      // This is overwritten when children are created, but done\n      // as a default here to keep the code cleaner. Instantiating\n      // this object is pretty cheap anyway.\n      this.rectangle = new KnapsackRectangle( 0, 0, knapsack.textureSize, knapsack.textureSize );\n    }\n\n    get canvas ()  { return this.knapsack.canvas; }\n    get context () { return this.knapsack.canvas.getContext('2d'); }\n\n    get width ()   { return this.rectangle.width; }\n    get height ()  { return this.rectangle.height; }\n\n    get texture () {\n      if ( ! this._texture ) {\n        this._texture = this.knapsack.rootTexture.clone();\n        this._texture.uuid = this.knapsack.rootTexture.uuid;\n        var uvExtremes = this.uvCoordinates();\n        this.texture.offset.x = uvExtremes[ 0 ];\n        this.texture.offset.y = uvExtremes[ 1 ];\n        this.texture.repeat.x = uvExtremes[ 2 ] - uvExtremes[ 0 ];\n        this.texture.repeat.y = uvExtremes[ 3 ] - uvExtremes[ 1 ];\n      }\n      return this._texture;\n    }\n\n    hasChildren() {\n      return ( ( this.leftChild !== null ) || ( this.rightChild !== null ) );\n    }\n\n    isOccupied() {\n      return ( this.imageID !== null );\n    }\n\n    uvCoordinates() {\n      var size = this.knapsack.textureSize;\n      return [\n            ( this.rectangle.left   / size ),\n        1 - ( this.rectangle.bottom / size ),\n            ( this.rectangle.right  / size ),\n        1 - ( this.rectangle.top    / size ),\n      ];\n    }\n\n    release() {\n      if ( this.hasChildren() ) {\n        throw new Error( 'Can not release tree node, still has children' );\n      }\n\n      if ( this._texture !== null ) {\n        this._texture.dispose();\n        this._texture = null;\n      }\n\n      this.clear();\n      this.imageID = null;\n\n      return;\n    }\n\n    // Clear the area of the node\n    clear() {\n      this.context.clearRect( this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1 );\n    }\n\n    // Set the context to the centre of the node, and make sure to clip anything\n    // outside of the node; this makes it easier to draw in it\n    clipContext() {\n      var ctx = this.context;\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect( this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2 );\n      ctx.clip();\n      ctx.translate( this.rectangle.Xcentre, this.rectangle.Ycentre );\n      return ctx;\n    }\n\n    // Restore the context of the canvas, call this when done drawing the sprite.\n    restoreContext() {\n      this.context.restore();\n    }\n\n    allocate( width, height ) {\n      // If we're not a leaf node\n      if ( this.hasChildren() )\n      {\n        // then try inserting into our first child\n        var newNode = this.leftChild.allocate( width, height );\n        if ( newNode instanceof KnapsackNode ) {\n          newNode.claim();\n          return newNode;\n        }\n\n        // There was no room: try to insert into second child\n        return this.rightChild.allocate( width, height );\n      }\n      else\n      {\n        // if there's already an image here, return\n        if ( this.isOccupied() ) {\n          return null;\n        }\n\n        // if this node is too small, give up here\n        if ( ( width > this.width ) || ( height > this.height ) ) {\n          return null;\n        }\n\n        // if we're just the right size, accept\n        if ( width === this.width && height === this.height ) {\n          this.claim();\n          return this;\n        }\n\n        // otherwise, got to split this node and create some kids\n        this.leftChild  = new KnapsackNode( this.knapsack );\n        this.rightChild = new KnapsackNode( this.knapsack );\n\n        // now decide which way to split\n        var remainingWidth  = this.width  - width;\n        var remainingHeight = this.height - height;\n\n        if ( remainingWidth > remainingHeight )\n        {\n          // horizontal split\n          this.leftChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top,\n            this.rectangle.left + width,\n            this.rectangle.bottom\n          );\n\n          this.rightChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left + width,\n            this.rectangle.top,\n            this.rectangle.right,\n            this.rectangle.bottom\n          );\n        }\n        else\n        {\n          // vertical split\n          this.leftChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top,\n            this.rectangle.right,\n            this.rectangle.top + height\n          );\n\n          this.rightChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top + height,\n            this.rectangle.right,\n            this.rectangle.bottom\n          );\n        }\n\n        // Some crude painting to help troubleshooting\n        if ( this.knapsack.textureManager.debug ) {\n          var context = this.context;\n          context.lineWidth = 4.0;\n          context.strokeStyle = 'rgba(255,0,0,1)';\n          context.strokeRect( this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height );\n\n          context.lineWidth = 4.0;\n          context.strokeStyle = 'rgba(0,255,0,1)';\n          context.strokeRect( this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height );\n        }\n\n        // Recurse into the first child to continue the allocation\n        return this.leftChild.allocate( width, height );\n      }\n    }\n\n    // \"Allocate\" the node by giving it a (unique) ID for an image,\n    // this prevents it from being used for another image.\n    claim() {\n      this.imageID = THREE.Math.generateUUID();\n\n      // Some crude painting to help troubleshooting\n      if ( this.knapsack.textureManager.debug ) {\n        var context = this.context;\n        context.lineWidth = 2.0;\n        context.strokeStyle = 'rgba( 0, 0, 255, 1 )';\n        context.strokeRect( this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1 );\n      }\n    }\n  }\n\n  /*\n   * Helper classes to generate a texture map for sprites of various sizes.\n   *\n   * Represents a single texture atlas and canvas\n   *\n   * Based on: http://www.blackpawn.com/texts/lightmaps/default.html\n   */\n\n  class Knapsack {\n    constructor( textureManager, size ) {\n      this.textureManager = textureManager;\n      this.textureSize = size;\n      this.textureLoaded = false;\n      this.rootNode = new KnapsackNode( this );\n      // Lazy initialising these:\n      this._rootTexture = null;\n      this._canvas = null;\n    }\n\n    // Lazily build the canvas\n    get canvas () {\n      if ( ! this._canvas ) {\n        this._canvas = document.createElement('canvas');\n        this._canvas.width  = this.textureSize;\n        this._canvas.height = this.textureSize;\n      }\n      return this._canvas;\n    }\n\n    // Each node will .clone() this for itself\n    get rootTexture () {\n      if ( ! this._rootTexture ) {\n        this._rootTexture = new THREE.Texture( this.canvas, THREE.UVMapping );\n      }\n      return this._rootTexture;\n    }\n\n    // Method proxy, adds the given size to the bag if possible\n    allocateNode( width, height ) {\n      return this.rootNode.allocate( width, height );\n    }\n  }\n\n  /*\n   * Manages the texture canvas(es) for the system labels using the Knapsack class\n   */\n\n  class TextureManager {\n    constructor( size ) {\n      this.size = ( typeof size === 'number' && /^(128|256|512|1024|2048|4096|8192|16384)$/.test( size ) ) ? size : 1024;\n      this.knapsacks = [];\n      this.debug = false;\n    }\n\n    _addKnapsack( size ) {\n      var knapsack = new Knapsack( this, size );\n      this.knapsacks.push( knapsack );\n      if ( this.debug ) {\n        console.log( `TextureManager: allocated ${ this.textureSize }px texture map #${ this.knapsacks.length }` );\n      }\n      return knapsack;\n    }\n\n    get textureSize () {\n      return this.size;\n    }\n\n    // Claim a texture atlas slot for an image of width x height pixels,\n    // will create a new texture atlas if needed.\n    // Returns a Promise.\n    allocateNode( width, height ) {\n      var self = this;\n\n      return ( new Promise( function( resolve, reject ) {\n        let node;\n\n        // Prevent allocating knapsacks when there's no chance to fit the node\n        // FIXME TODO: try a bigger texture size if it doesn't fit?\n        if ( width > self.textureSize ) {\n          reject( Error( `A width of ${ width } is too large for these textures` ) );\n          return;\n        }\n\n        if ( height > self.textureSize ) {\n          reject( Error( `A height of ${ height } is too large for these textures` ) );\n          return;\n        }\n\n        if ( ! self.knapsacks.length ) {\n          self._addKnapsack( self.size );\n        }\n\n        // First try to get a node from the existing knapsacks\n        self.knapsacks.forEach( function( knapsack ) {\n          if ( node === null || node === undefined ) {\n            node = knapsack.allocateNode( width, height );\n          }\n        });\n\n        // If we didn't get a node here, but it should fit in a knapsack\n        // of the same size, so we can allocate a new knapsack\n        if ( node === null && ( width <= self.textureSize ) )\n        {\n          // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size\n          let knapsack = self._addKnapsack( self.textureSize );\n          node = knapsack.allocateNode( width, height );\n        }\n\n        if ( node === null || node === undefined ) {\n          reject( Error( `Could not allocate a node of size ${ width }x${ height }` ) );\n        } else {\n          resolve( node );\n        }\n      }));\n    }\n\n    release( node ) {\n      if ( node ) {\n        node.release();\n      }\n    }\n  }\n\n  var three_sprite_texture_atlas_manager = TextureManager;\n\n  return three_sprite_texture_atlas_manager;\n\n}));\n","/*\n * Helper classes to generate a texture map for sprites of various sizes.\n *\n * Simple class to describe a rectangular area witin the knapsack.\n */\n\nclass KnapsackRectangle {\n  constructor( left, top, right, bottom ) {\n    this.left   = Math.floor( ( typeof left   === 'number' && isFinite( left   ) ) ? left   : 0 );\n    this.top    = Math.floor( ( typeof top    === 'number' && isFinite( top    ) ) ? top    : 0 );\n    this.right  = Math.floor( ( typeof right  === 'number' && isFinite( right  ) ) ? right  : 0 );\n    this.bottom = Math.floor( ( typeof bottom === 'number' && isFinite( bottom ) ) ? bottom : 0 );\n  }\n\n  get Xcentre () { return Math.floor( ( ( this.right - this.left ) / 2 ) + this.left ) - 0.5; }\n  get Ycentre () { return Math.floor( ( ( this.bottom - this.top ) / 2 ) + this.top  ) - 0.5; }\n  get width ()  { return ( this.right - this.left ); }\n  get height () { return ( this.bottom - this.top ); }\n}\n\nexport default KnapsackRectangle;\n","/*\n * Represents a single texture \"node\" within a larger texture atlas.\n *\n * Based on: http://www.blackpawn.com/texts/lightmaps/default.html\n */\n\nimport KnapsackRectangle from './knapsack-rectangle';\n\nclass KnapsackNode {\n  constructor( knapsack ) {\n    this.knapsack = knapsack;\n    this.leftChild = null;\n    this.rightChild = null;\n    this.rectangle = null;\n    this.imageID = null;\n    this._texture = null;\n\n    // This is overwritten when children are created, but done\n    // as a default here to keep the code cleaner. Instantiating\n    // this object is pretty cheap anyway.\n    this.rectangle = new KnapsackRectangle( 0, 0, knapsack.textureSize, knapsack.textureSize );\n  }\n\n  get canvas ()  { return this.knapsack.canvas; }\n  get context () { return this.knapsack.canvas.getContext('2d'); }\n\n  get width ()   { return this.rectangle.width; }\n  get height ()  { return this.rectangle.height; }\n\n  get texture () {\n    if ( ! this._texture ) {\n      this._texture = this.knapsack.rootTexture.clone();\n      this._texture.uuid = this.knapsack.rootTexture.uuid;\n      var uvExtremes = this.uvCoordinates();\n      this.texture.offset.x = uvExtremes[ 0 ];\n      this.texture.offset.y = uvExtremes[ 1 ];\n      this.texture.repeat.x = uvExtremes[ 2 ] - uvExtremes[ 0 ];\n      this.texture.repeat.y = uvExtremes[ 3 ] - uvExtremes[ 1 ];\n    }\n    return this._texture;\n  }\n\n  hasChildren() {\n    return ( ( this.leftChild !== null ) || ( this.rightChild !== null ) );\n  }\n\n  isOccupied() {\n    return ( this.imageID !== null );\n  }\n\n  uvCoordinates() {\n    var size = this.knapsack.textureSize;\n    return [\n          ( this.rectangle.left   / size ),\n      1 - ( this.rectangle.bottom / size ),\n          ( this.rectangle.right  / size ),\n      1 - ( this.rectangle.top    / size ),\n    ];\n  }\n\n  release() {\n    if ( this.hasChildren() ) {\n      throw new Error( 'Can not release tree node, still has children' );\n    }\n\n    if ( this._texture !== null ) {\n      this._texture.dispose();\n      this._texture = null;\n    }\n\n    this.clear();\n    this.imageID = null;\n\n    return;\n  }\n\n  // Clear the area of the node\n  clear() {\n    this.context.clearRect( this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1 );\n  }\n\n  // Set the context to the centre of the node, and make sure to clip anything\n  // outside of the node; this makes it easier to draw in it\n  clipContext() {\n    var ctx = this.context;\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect( this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2 );\n    ctx.clip();\n    ctx.translate( this.rectangle.Xcentre, this.rectangle.Ycentre );\n    return ctx;\n  }\n\n  // Restore the context of the canvas, call this when done drawing the sprite.\n  restoreContext() {\n    this.context.restore();\n  }\n\n  allocate( width, height ) {\n    // If we're not a leaf node\n    if ( this.hasChildren() )\n    {\n      // then try inserting into our first child\n      var newNode = this.leftChild.allocate( width, height );\n      if ( newNode instanceof KnapsackNode ) {\n        newNode.claim();\n        return newNode;\n      }\n\n      // There was no room: try to insert into second child\n      return this.rightChild.allocate( width, height );\n    }\n    else\n    {\n      // if there's already an image here, return\n      if ( this.isOccupied() ) {\n        return null;\n      }\n\n      // if this node is too small, give up here\n      if ( ( width > this.width ) || ( height > this.height ) ) {\n        return null;\n      }\n\n      // if we're just the right size, accept\n      if ( width === this.width && height === this.height ) {\n        this.claim();\n        return this;\n      }\n\n      // otherwise, got to split this node and create some kids\n      this.leftChild  = new KnapsackNode( this.knapsack );\n      this.rightChild = new KnapsackNode( this.knapsack );\n\n      // now decide which way to split\n      var remainingWidth  = this.width  - width;\n      var remainingHeight = this.height - height;\n\n      if ( remainingWidth > remainingHeight )\n      {\n        // horizontal split\n        this.leftChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top,\n          this.rectangle.left + width,\n          this.rectangle.bottom\n        );\n\n        this.rightChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left + width,\n          this.rectangle.top,\n          this.rectangle.right,\n          this.rectangle.bottom\n        );\n      }\n      else\n      {\n        // vertical split\n        this.leftChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top,\n          this.rectangle.right,\n          this.rectangle.top + height\n        );\n\n        this.rightChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top + height,\n          this.rectangle.right,\n          this.rectangle.bottom\n        );\n      }\n\n      // Some crude painting to help troubleshooting\n      if ( this.knapsack.textureManager.debug ) {\n        var context = this.context;\n        context.lineWidth = 4.0;\n        context.strokeStyle = 'rgba(255,0,0,1)';\n        context.strokeRect( this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height );\n\n        context.lineWidth = 4.0;\n        context.strokeStyle = 'rgba(0,255,0,1)';\n        context.strokeRect( this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height );\n      }\n\n      // Recurse into the first child to continue the allocation\n      return this.leftChild.allocate( width, height );\n    }\n  }\n\n  // \"Allocate\" the node by giving it a (unique) ID for an image,\n  // this prevents it from being used for another image.\n  claim() {\n    this.imageID = THREE.Math.generateUUID();\n\n    // Some crude painting to help troubleshooting\n    if ( this.knapsack.textureManager.debug ) {\n      var context = this.context;\n      context.lineWidth = 2.0;\n      context.strokeStyle = 'rgba( 0, 0, 255, 1 )';\n      context.strokeRect( this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1 );\n    }\n  }\n}\n\nexport default KnapsackNode;\n","/*\n * Helper classes to generate a texture map for sprites of various sizes.\n *\n * Represents a single texture atlas and canvas\n *\n * Based on: http://www.blackpawn.com/texts/lightmaps/default.html\n */\n\nimport KnapsackNode from './knapsack-node';\n\nclass Knapsack {\n  constructor( textureManager, size ) {\n    this.textureManager = textureManager;\n    this.textureSize = size;\n    this.textureLoaded = false;\n    this.rootNode = new KnapsackNode( this );\n    // Lazy initialising these:\n    this._rootTexture = null;\n    this._canvas = null;\n  }\n\n  // Lazily build the canvas\n  get canvas () {\n    if ( ! this._canvas ) {\n      this._canvas = document.createElement('canvas');\n      this._canvas.width  = this.textureSize;\n      this._canvas.height = this.textureSize;\n    }\n    return this._canvas;\n  }\n\n  // Each node will .clone() this for itself\n  get rootTexture () {\n    if ( ! this._rootTexture ) {\n      this._rootTexture = new THREE.Texture( this.canvas, THREE.UVMapping );\n    }\n    return this._rootTexture;\n  }\n\n  // Method proxy, adds the given size to the bag if possible\n  allocateNode( width, height ) {\n    return this.rootNode.allocate( width, height );\n  }\n}\n\nexport default Knapsack;\n","/*\n * Manages the texture canvas(es) for the system labels using the Knapsack class\n */\n\nimport Knapsack from './knapsack';\n\nclass TextureManager {\n  constructor( size ) {\n    this.size = ( typeof size === 'number' && /^(128|256|512|1024|2048|4096|8192|16384)$/.test( size ) ) ? size : 1024;\n    this.knapsacks = [];\n    this.debug = false;\n  }\n\n  _addKnapsack( size ) {\n    var knapsack = new Knapsack( this, size );\n    this.knapsacks.push( knapsack );\n    if ( this.debug ) {\n      console.log( `TextureManager: allocated ${ this.textureSize }px texture map #${ this.knapsacks.length }` );\n    }\n    return knapsack;\n  }\n\n  get textureSize () {\n    return this.size;\n  }\n\n  // Claim a texture atlas slot for an image of width x height pixels,\n  // will create a new texture atlas if needed.\n  // Returns a Promise.\n  allocateNode( width, height ) {\n    var self = this;\n\n    return ( new Promise( function( resolve, reject ) {\n      let node;\n\n      // Prevent allocating knapsacks when there's no chance to fit the node\n      // FIXME TODO: try a bigger texture size if it doesn't fit?\n      if ( width > self.textureSize ) {\n        reject( Error( `A width of ${ width } is too large for these textures` ) );\n        return;\n      }\n\n      if ( height > self.textureSize ) {\n        reject( Error( `A height of ${ height } is too large for these textures` ) );\n        return;\n      }\n\n      if ( ! self.knapsacks.length ) {\n        self._addKnapsack( self.size );\n      }\n\n      // First try to get a node from the existing knapsacks\n      self.knapsacks.forEach( function( knapsack ) {\n        if ( node === null || node === undefined ) {\n          node = knapsack.allocateNode( width, height );\n        }\n      });\n\n      // If we didn't get a node here, but it should fit in a knapsack\n      // of the same size, so we can allocate a new knapsack\n      if ( node === null && ( width <= self.textureSize ) )\n      {\n        // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size\n        let knapsack = self._addKnapsack( self.textureSize );\n        node = knapsack.allocateNode( width, height );\n      }\n\n      if ( node === null || node === undefined ) {\n        reject( Error( `Could not allocate a node of size ${ width }x${ height }` ) );\n      } else {\n        resolve( node );\n      }\n    }));\n  }\n\n  release( node ) {\n    if ( node ) {\n      node.release();\n    }\n  }\n}\n\nexport default TextureManager;\n","import TextureManager from './texture-manager';\nexport default TextureManager;\n"],"sourceRoot":"/source/"}