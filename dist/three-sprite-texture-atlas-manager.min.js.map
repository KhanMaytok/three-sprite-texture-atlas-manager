{"version":3,"sources":["three-sprite-texture-atlas-manager.min.js","/source/three-sprite-texture-atlas-manager.js","/source/src/knapsack-rectangle.js","/source/src/knapsack-node.js","/source/src/knapsack.js","/source/src/texture-manager.js","/source/src/three-sprite-texture-atlas-manager.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","threeSpriteAtlasTextureManager","this","KnapsackRectangle","left","top","right","bottom","Math","floor","isFinite","get","KnapsackNode","knapsack","leftChild","rightChild","rectangle","imageID","_texture","textureSize","value","size","hasChildren","Error","dispose","clear","context","clearRect","width","height","ctx","save","beginPath","rect","clip","translate","Xcentre","Ycentre","restore","newNode","allocate","claim","isOccupied","remainingWidth","remainingHeight","textureManager","debug","lineWidth","strokeStyle","strokeRect","THREE","generateUUID","canvas","getContext","rootTexture","clone","uuid","uvExtremes","uvCoordinates","texture","offset","x","y","repeat","Knapsack","textureLoaded","rootNode","_rootTexture","_canvas","document","createElement","Texture","UVMapping","TextureManager","test","knapsacks","push","console","log","self","Promise","resolve","reject","node","undefined","_addKnapsack","forEach","allocateNode","release","three_sprite_texture_atlas_manager"],"mappings":"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","file":"three-sprite-texture-atlas-manager.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.threeSpriteAtlasTextureManager = factory()\n}(this, function () { 'use strict';\n\n  /*\n   * Helper classes to generate a texture map for sprites of various sizes.\n   *\n   * Simple class to describe a rectangular area witin the knapsack.\n   */\n\n  class KnapsackRectangle {\n    constructor( left, top, right, bottom ) {\n      this.left   = Math.floor( ( typeof left   === 'number' && isFinite( left   ) ) ? left   : 0 );\n      this.top    = Math.floor( ( typeof top    === 'number' && isFinite( top    ) ) ? top    : 0 );\n      this.right  = Math.floor( ( typeof right  === 'number' && isFinite( right  ) ) ? right  : 0 );\n      this.bottom = Math.floor( ( typeof bottom === 'number' && isFinite( bottom ) ) ? bottom : 0 );\n    }\n\n    get Xcentre () { return Math.floor( ( ( this.right - this.left ) / 2 ) + this.left ) - 0.5; }\n    get Ycentre () { return Math.floor( ( ( this.bottom - this.top ) / 2 ) + this.top  ) - 0.5; }\n    get width ()  { return ( this.right - this.left ); }\n    get height () { return ( this.bottom - this.top ); }\n  }\n\n  /*\n   * Represents a single texture \"node\" within a larger texture atlas.\n   *\n   * Based on: http://www.blackpawn.com/texts/lightmaps/default.html\n   */\n\n  class KnapsackNode {\n    constructor( knapsack ) {\n      this.knapsack = knapsack;\n      this.leftChild = null;\n      this.rightChild = null;\n      this.rectangle = null;\n      this.imageID = null;\n      this._texture = null;\n\n      // This is overwritten when children are created, but done\n      // as a default here to keep the code cleaner. Instantiating\n      // this object is pretty cheap anyway.\n      this.rectangle = new KnapsackRectangle( 0, 0, knapsack.textureSize, knapsack.textureSize );\n    }\n\n    get canvas ()  { return this.knapsack.canvas; }\n    get context () { return this.knapsack.canvas.getContext('2d'); }\n\n    get width ()   { return this.rectangle.width; }\n    get height ()  { return this.rectangle.height; }\n\n    get texture () {\n      if ( ! this._texture ) {\n        this._texture = this.knapsack.rootTexture.clone();\n        this._texture.uuid = this.knapsack.rootTexture.uuid;\n        var uvExtremes = this.uvCoordinates();\n        this.texture.offset.x = uvExtremes[ 0 ];\n        this.texture.offset.y = uvExtremes[ 1 ];\n        this.texture.repeat.x = uvExtremes[ 2 ] - uvExtremes[ 0 ];\n        this.texture.repeat.y = uvExtremes[ 3 ] - uvExtremes[ 1 ];\n      }\n      return this._texture;\n    }\n\n    hasChildren() {\n      return ( ( this.leftChild !== null ) || ( this.rightChild !== null ) );\n    }\n\n    isOccupied() {\n      return ( this.imageID !== null );\n    }\n\n    uvCoordinates() {\n      var size = this.knapsack.textureSize;\n      return [\n            ( this.rectangle.left   / size ),\n        1 - ( this.rectangle.bottom / size ),\n            ( this.rectangle.right  / size ),\n        1 - ( this.rectangle.top    / size ),\n      ];\n    }\n\n    release() {\n      if ( this.hasChildren() ) {\n        throw new Error( 'Can not release tree node, still has children' );\n      }\n\n      if ( this._texture !== null ) {\n        this._texture.dispose();\n        this._texture = null;\n      }\n\n      this.clear();\n      this.imageID = null;\n\n      return;\n    }\n\n    // Clear the area of the node\n    clear() {\n      this.context.clearRect( this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1 );\n    }\n\n    // Set the context to the centre of the node, and make sure to clip anything\n    // outside of the node; this makes it easier to draw in it\n    clipContext() {\n      var ctx = this.context;\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect( this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2 );\n      ctx.clip();\n      ctx.translate( this.rectangle.Xcentre, this.rectangle.Ycentre );\n      return ctx;\n    }\n\n    // Restore the context of the canvas, call this when done drawing the sprite.\n    restoreContext() {\n      this.context.restore();\n    }\n\n    allocate( width, height ) {\n      // If we're not a leaf node\n      if ( this.hasChildren() )\n      {\n        // then try inserting into our first child\n        var newNode = this.leftChild.allocate( width, height );\n        if ( newNode instanceof KnapsackNode ) {\n          newNode.claim();\n          return newNode;\n        }\n\n        // There was no room: try to insert into second child\n        return this.rightChild.allocate( width, height );\n      }\n      else\n      {\n        // if there's already an image here, return\n        if ( this.isOccupied() ) {\n          return null;\n        }\n\n        // if this node is too small, give up here\n        if ( ( width > this.width ) || ( height > this.height ) ) {\n          return null;\n        }\n\n        // if we're just the right size, accept\n        if ( width === this.width && height === this.height ) {\n          this.claim();\n          return this;\n        }\n\n        // otherwise, got to split this node and create some kids\n        this.leftChild  = new KnapsackNode( this.knapsack );\n        this.rightChild = new KnapsackNode( this.knapsack );\n\n        // now decide which way to split\n        var remainingWidth  = this.width  - width;\n        var remainingHeight = this.height - height;\n\n        if ( remainingWidth > remainingHeight )\n        {\n          // horizontal split\n          this.leftChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top,\n            this.rectangle.left + width,\n            this.rectangle.bottom\n          );\n\n          this.rightChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left + width,\n            this.rectangle.top,\n            this.rectangle.right,\n            this.rectangle.bottom\n          );\n        }\n        else\n        {\n          // vertical split\n          this.leftChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top,\n            this.rectangle.right,\n            this.rectangle.top + height\n          );\n\n          this.rightChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top + height,\n            this.rectangle.right,\n            this.rectangle.bottom\n          );\n        }\n\n        // Some crude painting to help troubleshooting\n        if ( this.knapsack.textureManager.debug ) {\n          var context = this.context;\n          context.lineWidth = 4.0;\n          context.strokeStyle = 'rgba(255,0,0,1)';\n          context.strokeRect( this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height );\n\n          context.lineWidth = 4.0;\n          context.strokeStyle = 'rgba(0,255,0,1)';\n          context.strokeRect( this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height );\n        }\n\n        // Recurse into the first child to continue the allocation\n        return this.leftChild.allocate( width, height );\n      }\n    }\n\n    // \"Allocate\" the node by giving it a (unique) ID for an image,\n    // this prevents it from being used for another image.\n    claim() {\n      this.imageID = THREE.Math.generateUUID();\n\n      // Some crude painting to help troubleshooting\n      if ( this.knapsack.textureManager.debug ) {\n        var context = this.context;\n        context.lineWidth = 2.0;\n        context.strokeStyle = 'rgba( 0, 0, 255, 1 )';\n        context.strokeRect( this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1 );\n      }\n    }\n  }\n\n  /*\n   * Helper classes to generate a texture map for sprites of various sizes.\n   *\n   * Represents a single texture atlas and canvas\n   *\n   * Based on: http://www.blackpawn.com/texts/lightmaps/default.html\n   */\n\n  class Knapsack {\n    constructor( textureManager, size ) {\n      this.textureManager = textureManager;\n      this.textureSize = size;\n      this.textureLoaded = false;\n      this.rootNode = new KnapsackNode( this );\n      // Lazy initialising these:\n      this._rootTexture = null;\n      this._canvas = null;\n    }\n\n    // Lazily build the canvas\n    get canvas () {\n      if ( ! this._canvas ) {\n        this._canvas = document.createElement('canvas');\n        this._canvas.width  = this.textureSize;\n        this._canvas.height = this.textureSize;\n      }\n      return this._canvas;\n    }\n\n    // Each node will .clone() this for itself\n    get rootTexture () {\n      if ( ! this._rootTexture ) {\n        this._rootTexture = new THREE.Texture( this.canvas, THREE.UVMapping );\n      }\n      return this._rootTexture;\n    }\n\n    // Method proxy, adds the given size to the bag if possible\n    allocateNode( width, height ) {\n      return this.rootNode.allocate( width, height );\n    }\n  }\n\n  /*\n   * Manages the texture canvas(es) for the system labels using the Knapsack class\n   */\n\n  class TextureManager {\n    constructor( size ) {\n      this.size = ( typeof size === 'number' && /^(128|256|512|1024|2048|4096|8192|16384)$/.test( size ) ) ? size : 1024;\n      this.knapsacks = [];\n      this.debug = false;\n    }\n\n    _addKnapsack( size ) {\n      var knapsack = new Knapsack( this, size );\n      this.knapsacks.push( knapsack );\n      if ( this.debug ) {\n        console.log( `TextureManager: allocated ${ this.textureSize }px texture map #${ this.knapsacks.length }` );\n      }\n      return knapsack;\n    }\n\n    get textureSize () {\n      return this.size;\n    }\n\n    // Claim a texture atlas slot for an image of width x height pixels,\n    // will create a new texture atlas if needed.\n    // Returns a Promise.\n    allocateNode( width, height ) {\n      var self = this;\n\n      return ( new Promise( function( resolve, reject ) {\n        let node;\n\n        // Prevent allocating knapsacks when there's no chance to fit the node\n        // FIXME TODO: try a bigger texture size if it doesn't fit?\n        if ( width > self.textureSize ) {\n          reject( Error( `A width of ${ width } is too large for these textures` ) );\n          return;\n        }\n\n        if ( height > self.textureSize ) {\n          reject( Error( `A height of ${ height } is too large for these textures` ) );\n          return;\n        }\n\n        if ( ! self.knapsacks.length ) {\n          self._addKnapsack( self.size );\n        }\n\n        // First try to get a node from the existing knapsacks\n        self.knapsacks.forEach( function( knapsack ) {\n          if ( node === null || node === undefined ) {\n            node = knapsack.allocateNode( width, height );\n          }\n        });\n\n        // If we didn't get a node here, but it should fit in a knapsack\n        // of the same size, so we can allocate a new knapsack\n        if ( node === null && ( width <= self.textureSize ) )\n        {\n          // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size\n          let knapsack = self._addKnapsack( self.textureSize );\n          node = knapsack.allocateNode( width, height );\n        }\n\n        if ( node === null || node === undefined ) {\n          reject( Error( `Could not allocate a node of size ${ width }x${ height }` ) );\n        } else {\n          resolve( node );\n        }\n      }));\n    }\n\n    release( node ) {\n      if ( node ) {\n        node.release();\n      }\n    }\n  }\n\n  var three_sprite_texture_atlas_manager = TextureManager;\n\n  return three_sprite_texture_atlas_manager;\n\n}));\n","/*\n * Helper classes to generate a texture map for sprites of various sizes.\n *\n * Simple class to describe a rectangular area witin the knapsack.\n */\n\nclass KnapsackRectangle {\n  constructor( left, top, right, bottom ) {\n    this.left   = Math.floor( ( typeof left   === 'number' && isFinite( left   ) ) ? left   : 0 );\n    this.top    = Math.floor( ( typeof top    === 'number' && isFinite( top    ) ) ? top    : 0 );\n    this.right  = Math.floor( ( typeof right  === 'number' && isFinite( right  ) ) ? right  : 0 );\n    this.bottom = Math.floor( ( typeof bottom === 'number' && isFinite( bottom ) ) ? bottom : 0 );\n  }\n\n  get Xcentre () { return Math.floor( ( ( this.right - this.left ) / 2 ) + this.left ) - 0.5; }\n  get Ycentre () { return Math.floor( ( ( this.bottom - this.top ) / 2 ) + this.top  ) - 0.5; }\n  get width ()  { return ( this.right - this.left ); }\n  get height () { return ( this.bottom - this.top ); }\n}\n\nexport default KnapsackRectangle;\n","/*\n * Represents a single texture \"node\" within a larger texture atlas.\n *\n * Based on: http://www.blackpawn.com/texts/lightmaps/default.html\n */\n\nimport KnapsackRectangle from './knapsack-rectangle';\n\nclass KnapsackNode {\n  constructor( knapsack ) {\n    this.knapsack = knapsack;\n    this.leftChild = null;\n    this.rightChild = null;\n    this.rectangle = null;\n    this.imageID = null;\n    this._texture = null;\n\n    // This is overwritten when children are created, but done\n    // as a default here to keep the code cleaner. Instantiating\n    // this object is pretty cheap anyway.\n    this.rectangle = new KnapsackRectangle( 0, 0, knapsack.textureSize, knapsack.textureSize );\n  }\n\n  get canvas ()  { return this.knapsack.canvas; }\n  get context () { return this.knapsack.canvas.getContext('2d'); }\n\n  get width ()   { return this.rectangle.width; }\n  get height ()  { return this.rectangle.height; }\n\n  get texture () {\n    if ( ! this._texture ) {\n      this._texture = this.knapsack.rootTexture.clone();\n      this._texture.uuid = this.knapsack.rootTexture.uuid;\n      var uvExtremes = this.uvCoordinates();\n      this.texture.offset.x = uvExtremes[ 0 ];\n      this.texture.offset.y = uvExtremes[ 1 ];\n      this.texture.repeat.x = uvExtremes[ 2 ] - uvExtremes[ 0 ];\n      this.texture.repeat.y = uvExtremes[ 3 ] - uvExtremes[ 1 ];\n    }\n    return this._texture;\n  }\n\n  hasChildren() {\n    return ( ( this.leftChild !== null ) || ( this.rightChild !== null ) );\n  }\n\n  isOccupied() {\n    return ( this.imageID !== null );\n  }\n\n  uvCoordinates() {\n    var size = this.knapsack.textureSize;\n    return [\n          ( this.rectangle.left   / size ),\n      1 - ( this.rectangle.bottom / size ),\n          ( this.rectangle.right  / size ),\n      1 - ( this.rectangle.top    / size ),\n    ];\n  }\n\n  release() {\n    if ( this.hasChildren() ) {\n      throw new Error( 'Can not release tree node, still has children' );\n    }\n\n    if ( this._texture !== null ) {\n      this._texture.dispose();\n      this._texture = null;\n    }\n\n    this.clear();\n    this.imageID = null;\n\n    return;\n  }\n\n  // Clear the area of the node\n  clear() {\n    this.context.clearRect( this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1 );\n  }\n\n  // Set the context to the centre of the node, and make sure to clip anything\n  // outside of the node; this makes it easier to draw in it\n  clipContext() {\n    var ctx = this.context;\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect( this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2 );\n    ctx.clip();\n    ctx.translate( this.rectangle.Xcentre, this.rectangle.Ycentre );\n    return ctx;\n  }\n\n  // Restore the context of the canvas, call this when done drawing the sprite.\n  restoreContext() {\n    this.context.restore();\n  }\n\n  allocate( width, height ) {\n    // If we're not a leaf node\n    if ( this.hasChildren() )\n    {\n      // then try inserting into our first child\n      var newNode = this.leftChild.allocate( width, height );\n      if ( newNode instanceof KnapsackNode ) {\n        newNode.claim();\n        return newNode;\n      }\n\n      // There was no room: try to insert into second child\n      return this.rightChild.allocate( width, height );\n    }\n    else\n    {\n      // if there's already an image here, return\n      if ( this.isOccupied() ) {\n        return null;\n      }\n\n      // if this node is too small, give up here\n      if ( ( width > this.width ) || ( height > this.height ) ) {\n        return null;\n      }\n\n      // if we're just the right size, accept\n      if ( width === this.width && height === this.height ) {\n        this.claim();\n        return this;\n      }\n\n      // otherwise, got to split this node and create some kids\n      this.leftChild  = new KnapsackNode( this.knapsack );\n      this.rightChild = new KnapsackNode( this.knapsack );\n\n      // now decide which way to split\n      var remainingWidth  = this.width  - width;\n      var remainingHeight = this.height - height;\n\n      if ( remainingWidth > remainingHeight )\n      {\n        // horizontal split\n        this.leftChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top,\n          this.rectangle.left + width,\n          this.rectangle.bottom\n        );\n\n        this.rightChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left + width,\n          this.rectangle.top,\n          this.rectangle.right,\n          this.rectangle.bottom\n        );\n      }\n      else\n      {\n        // vertical split\n        this.leftChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top,\n          this.rectangle.right,\n          this.rectangle.top + height\n        );\n\n        this.rightChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top + height,\n          this.rectangle.right,\n          this.rectangle.bottom\n        );\n      }\n\n      // Some crude painting to help troubleshooting\n      if ( this.knapsack.textureManager.debug ) {\n        var context = this.context;\n        context.lineWidth = 4.0;\n        context.strokeStyle = 'rgba(255,0,0,1)';\n        context.strokeRect( this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height );\n\n        context.lineWidth = 4.0;\n        context.strokeStyle = 'rgba(0,255,0,1)';\n        context.strokeRect( this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height );\n      }\n\n      // Recurse into the first child to continue the allocation\n      return this.leftChild.allocate( width, height );\n    }\n  }\n\n  // \"Allocate\" the node by giving it a (unique) ID for an image,\n  // this prevents it from being used for another image.\n  claim() {\n    this.imageID = THREE.Math.generateUUID();\n\n    // Some crude painting to help troubleshooting\n    if ( this.knapsack.textureManager.debug ) {\n      var context = this.context;\n      context.lineWidth = 2.0;\n      context.strokeStyle = 'rgba( 0, 0, 255, 1 )';\n      context.strokeRect( this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1 );\n    }\n  }\n}\n\nexport default KnapsackNode;\n","/*\n * Helper classes to generate a texture map for sprites of various sizes.\n *\n * Represents a single texture atlas and canvas\n *\n * Based on: http://www.blackpawn.com/texts/lightmaps/default.html\n */\n\nimport KnapsackNode from './knapsack-node';\n\nclass Knapsack {\n  constructor( textureManager, size ) {\n    this.textureManager = textureManager;\n    this.textureSize = size;\n    this.textureLoaded = false;\n    this.rootNode = new KnapsackNode( this );\n    // Lazy initialising these:\n    this._rootTexture = null;\n    this._canvas = null;\n  }\n\n  // Lazily build the canvas\n  get canvas () {\n    if ( ! this._canvas ) {\n      this._canvas = document.createElement('canvas');\n      this._canvas.width  = this.textureSize;\n      this._canvas.height = this.textureSize;\n    }\n    return this._canvas;\n  }\n\n  // Each node will .clone() this for itself\n  get rootTexture () {\n    if ( ! this._rootTexture ) {\n      this._rootTexture = new THREE.Texture( this.canvas, THREE.UVMapping );\n    }\n    return this._rootTexture;\n  }\n\n  // Method proxy, adds the given size to the bag if possible\n  allocateNode( width, height ) {\n    return this.rootNode.allocate( width, height );\n  }\n}\n\nexport default Knapsack;\n","/*\n * Manages the texture canvas(es) for the system labels using the Knapsack class\n */\n\nimport Knapsack from './knapsack';\n\nclass TextureManager {\n  constructor( size ) {\n    this.size = ( typeof size === 'number' && /^(128|256|512|1024|2048|4096|8192|16384)$/.test( size ) ) ? size : 1024;\n    this.knapsacks = [];\n    this.debug = false;\n  }\n\n  _addKnapsack( size ) {\n    var knapsack = new Knapsack( this, size );\n    this.knapsacks.push( knapsack );\n    if ( this.debug ) {\n      console.log( `TextureManager: allocated ${ this.textureSize }px texture map #${ this.knapsacks.length }` );\n    }\n    return knapsack;\n  }\n\n  get textureSize () {\n    return this.size;\n  }\n\n  // Claim a texture atlas slot for an image of width x height pixels,\n  // will create a new texture atlas if needed.\n  // Returns a Promise.\n  allocateNode( width, height ) {\n    var self = this;\n\n    return ( new Promise( function( resolve, reject ) {\n      let node;\n\n      // Prevent allocating knapsacks when there's no chance to fit the node\n      // FIXME TODO: try a bigger texture size if it doesn't fit?\n      if ( width > self.textureSize ) {\n        reject( Error( `A width of ${ width } is too large for these textures` ) );\n        return;\n      }\n\n      if ( height > self.textureSize ) {\n        reject( Error( `A height of ${ height } is too large for these textures` ) );\n        return;\n      }\n\n      if ( ! self.knapsacks.length ) {\n        self._addKnapsack( self.size );\n      }\n\n      // First try to get a node from the existing knapsacks\n      self.knapsacks.forEach( function( knapsack ) {\n        if ( node === null || node === undefined ) {\n          node = knapsack.allocateNode( width, height );\n        }\n      });\n\n      // If we didn't get a node here, but it should fit in a knapsack\n      // of the same size, so we can allocate a new knapsack\n      if ( node === null && ( width <= self.textureSize ) )\n      {\n        // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size\n        let knapsack = self._addKnapsack( self.textureSize );\n        node = knapsack.allocateNode( width, height );\n      }\n\n      if ( node === null || node === undefined ) {\n        reject( Error( `Could not allocate a node of size ${ width }x${ height }` ) );\n      } else {\n        resolve( node );\n      }\n    }));\n  }\n\n  release( node ) {\n    if ( node ) {\n      node.release();\n    }\n  }\n}\n\nexport default TextureManager;\n","import TextureManager from './texture-manager';\nexport default TextureManager;\n"],"sourceRoot":"/source/"}