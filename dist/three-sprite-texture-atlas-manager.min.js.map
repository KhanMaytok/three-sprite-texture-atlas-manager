{"version":3,"sources":["three-sprite-texture-atlas-manager.min.js","/source/three-sprite-texture-atlas-manager.js","/source/src/texture-manager/knapsack/rectangle.js","/source/src/texture-manager/knapsack/node.js","/source/src/texture-manager/knapsack.js","/source/src/texture-manager.js","/source/src/three-sprite-texture-atlas-manager.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","threeSpriteAtlasTextureManager","this","KnapsackRectangle","left","top","right","bottom","Math","floor","isFinite","get","KnapsackNode","knapsack","leftChild","rightChild","rectangle","textureSize","imageID","_texture","value","size","hasChildren","Error","dispose","clear","context","clearRect","width","height","ctx","save","beginPath","rect","clip","translate","Xcentre","Ycentre","restore","newNode","allocate","claim","isOccupied","remainingWidth","remainingHeight","textureManager","debug","lineWidth","strokeStyle","strokeRect","THREE","generateUUID","canvas","getContext","rootTexture","clone","uuid","uvs","uvCoordinates","texture","offset","x","y","repeat","Knapsack","textureLoaded","rootNode","_rootTexture","_canvas","document","createElement","Texture","UVMapping","TextureManager","test","knapsacks","push","console","log","self","Promise","resolve","reject","node","undefined","_addKnapsack","forEach","allocateNode","release","three_sprite_texture_atlas_manager"],"mappings":"AAEA,QAASA,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAFhH,GAAIC,cAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,IAAiB,MAAO,UAAUR,EAAae,EAAYC,GAAiJ,MAA9HD,IAAYZ,EAAiBH,EAAYiB,UAAWF,GAAiBC,GAAab,EAAiBH,EAAagB,GAAqBhB,OCAjiB,SAAWkB,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,IAC9D,kBAAXG,SAAyBA,OAAOC,IAAMD,OAAOH,GACpDD,EAAOM,+BAAiCL,KACxCM,KAAM,WAAc,YDkBpB,IERIC,GAAA,WACO,QADPA,GACSC,EAAMC,EAAKC,EAAOC,GFS3BhC,gBAAgB2B,KEVhBC,GAEFD,KAAKE,KAASI,KAAKC,MAA2B,gBAAXL,IAAuBM,SAAUN,GAAaA,EAAS,GAC1FF,KAAKG,IAASG,KAAKC,MAA2B,gBAAXJ,IAAuBK,SAAUL,GAAaA,EAAS,GAC1FH,KAAKI,MAASE,KAAKC,MAA2B,gBAAXH,IAAuBI,SAAUJ,GAAaA,EAAS,GAC1FJ,KAAKK,OAASC,KAAKC,MAA2B,gBAAXF,IAAuBG,SAAUH,GAAaA,EAAS,GFiF1F,MAxCA5B,cE9CEwB,IF+CAZ,IAAK,UACLoB,IEnCQ,WAAK,MAAOH,MAAKC,OAAWP,KAAKI,MAAQJ,KAAKE,MAAS,EAAMF,KAAKE,MAAS,MF6CnFb,IAAK,UACLoB,IEvCQ,WAAK,MAAOH,MAAKC,OAAWP,KAAKK,OAASL,KAAKG,KAAQ,EAAMH,KAAKG,KAAS,MFiDnFd,IAAK,QACLoB,IE3CM,WAAM,MAAST,MAAKI,MAAQJ,KAAKE,QFqDvCb,IAAK,SACLoB,IE/CO,WAAK,MAAST,MAAKK,OAASL,KAAKG,QAlCxCF,KCWAS,EAAA,WACO,QADPA,GACSC,GH+ETtC,gBAAgB2B,KGhFhBU,GAQFV,KAAKW,SAAWA,EAQhBX,KAAKY,UAAY,KAQjBZ,KAAKa,WAAa,KAQlBb,KAAKc,UAAY,KAGjBd,KAAKc,UAAY,GAAIb,GAAmB,EAAG,EAAGU,EAASI,YAAaJ,EAASI,aAO7Ef,KAAKgB,QAAU,KAEfhB,KAAKiB,SAAW,KHqVhB,MAjPAxC,cGhJEiC,IHiJArB,IAAK,cAOL6B,MGtDO,WACT,MAA8B,QAArBlB,KAAOY,WAA8C,OAApBZ,KAAKa,cH+D7CxB,IAAK,aACL6B,MGxDM,WACR,MAA0B,QAAjBlB,KAAKgB,WHgEZ3B,IAAK,gBACL6B,MG1DS,WACX,GAAIC,GAAOnB,KAAKW,SAASI,WACzB,QACQf,KAAKc,UAAUZ,KAASiB,EAC9B,EAAMnB,KAAKc,UAAUT,OAASc,EACxBnB,KAAKc,UAAUV,MAASe,EAC9B,EAAMnB,KAAKc,UAAUX,IAASgB,MH6D9B9B,IAAK,UACL6B,MGvDG,WACL,GAAKlB,KAAKoB,cACR,KAAM,IAAIC,OAAO,gDAGI,QAAlBrB,KAAKiB,WACRjB,KAAKiB,SAASK,UACdtB,KAAKiB,SAAW,MAGlBjB,KAAKuB,QACLvB,KAAKgB,QAAU,QHgEb3B,IAAK,QACL6B,MGzDC,WACHlB,KAAKwB,QAAQC,UAAWzB,KAAKc,UAAUZ,KAAMF,KAAKc,UAAUX,IAAKH,KAAK0B,MAAQ,EAAG1B,KAAK2B,OAAS,MHiE7FtC,IAAK,cACL6B,MG3DO,WACT,GAAIU,GAAM5B,KAAKwB,OAMf,OALAI,GAAIC,OACJD,EAAIE,YACJF,EAAIG,KAAM/B,KAAKc,UAAUZ,KAAO,EAAGF,KAAKc,UAAUX,IAAM,EAAGH,KAAK0B,MAAQ,EAAG1B,KAAK2B,OAAS,GACzFC,EAAII,OACJJ,EAAIK,UAAWjC,KAAKc,UAAUoB,QAASlC,KAAKc,UAAUqB,SAC/CP,KHkELvC,IAAK,iBACL6B,MG7DU,WACZlB,KAAKwB,QAAQY,aHwEX/C,IAAK,WACL6B,MG/DI,SAAEQ,EAAOC,GAEf,GAAK3B,KAAKoB,cACV,CAEE,GAAIiB,GAAUrC,KAAKY,UAAU0B,SAAUZ,EAAOC,EAC9C,OAAKU,aAAmB3B,IACtB2B,EAAQE,QACDF,GAIFrC,KAAKa,WAAWyB,SAAUZ,EAAOC,GAKxC,GAAK3B,KAAKwC,aACR,MAAO,KAIT,IAAKd,EAAU1B,KAAK0B,OAAaC,EAAS3B,KAAK2B,OAC7C,MAAO,KAIT,IAAKD,IAAU1B,KAAK0B,OAASC,IAAW3B,KAAK2B,OAE3C,MADA3B,MAAKuC,QACEvC,IAITA,MAAKY,UAAa,GAAIF,GAAcV,KAAKW,UACzCX,KAAKa,WAAa,GAAIH,GAAcV,KAAKW,SAGzC,IAAI8B,GAAkBzC,KAAK0B,MAASA,EAChCgB,EAAkB1C,KAAK2B,OAASA,CAsCpC,IApCKc,EAAiBC,GAGpB1C,KAAKY,UAAUE,UAAY,GAAIb,GAC7BD,KAAKc,UAAUZ,KACfF,KAAKc,UAAUX,IACfH,KAAKc,UAAUZ,KAAOwB,EACtB1B,KAAKc,UAAUT,QAGjBL,KAAKa,WAAWC,UAAY,GAAIb,GAC9BD,KAAKc,UAAUZ,KAAOwB,EACtB1B,KAAKc,UAAUX,IACfH,KAAKc,UAAUV,MACfJ,KAAKc,UAAUT,UAMjBL,KAAKY,UAAUE,UAAY,GAAIb,GAC7BD,KAAKc,UAAUZ,KACfF,KAAKc,UAAUX,IACfH,KAAKc,UAAUV,MACfJ,KAAKc,UAAUX,IAAMwB,GAGvB3B,KAAKa,WAAWC,UAAY,GAAIb,GAC9BD,KAAKc,UAAUZ,KACfF,KAAKc,UAAUX,IAAMwB,EACrB3B,KAAKc,UAAUV,MACfJ,KAAKc,UAAUT,SAKdL,KAAKW,SAASgC,eAAeC,MAAQ,CACxC,GAAIpB,GAAUxB,KAAKwB,OACnBA,GAAQqB,UAAY,EACpBrB,EAAQsB,YAAc,kBACtBtB,EAAQuB,WAAY/C,KAAKY,UAAUE,UAAUZ,KAAMF,KAAKY,UAAUE,UAAUX,IAAKH,KAAKY,UAAUc,MAAO1B,KAAKY,UAAUe,QAEtHH,EAAQqB,UAAY,EACpBrB,EAAQsB,YAAc,kBACtBtB,EAAQuB,WAAY/C,KAAKa,WAAWC,UAAUZ,KAAMF,KAAKa,WAAWC,UAAUX,IAAKH,KAAKa,WAAWa,MAAO1B,KAAKa,WAAWc,QAI5H,MAAO3B,MAAKY,UAAU0B,SAAUZ,EAAOC,MH8CvCtC,IAAK,QACL6B,MGvCC,WAIH,GAHAlB,KAAKgB,QAAUgC,MAAM1C,KAAK2C,eAGrBjD,KAAKW,SAASgC,eAAeC,MAAQ,CACxC,GAAIpB,GAAUxB,KAAKwB,OACnBA,GAAQqB,UAAY,EACpBrB,EAAQsB,YAAc,uBACtBtB,EAAQuB,WAAY/C,KAAKc,UAAUZ,KAAO,GAAKF,KAAKc,UAAUX,IAAM,GAAKH,KAAK0B,MAAQ,EAAG1B,KAAK2B,OAAS,OH2CvGtC,IAAK,SACLoB,IGnRO,WAAK,MAAOT,MAAKW,SAASuC,UH6RjC7D,IAAK,UACLoB,IGvRQ,WAAK,MAAOT,MAAKW,SAASuC,OAAOC,WAAW,SHiSpD9D,IAAK,QACLoB,IG3RM,WAAK,MAAOT,MAAKc,UAAUY,SHqSjCrC,IAAK,SACLoB,IG/RO,WAAK,MAAOT,MAAKc,UAAUa,UHySlCtC,IAAK,UACLoB,IGnSQ,WACV,IAAOT,KAAKiB,SAAW,CACrBjB,KAAKiB,SAAWjB,KAAKW,SAASyC,YAAYC,QAC1CrD,KAAKiB,SAASqC,KAAOtD,KAAKW,SAASyC,YAAYE,IAC/C,IAAIC,GAAMvD,KAAKwD,eACfxD,MAAKyD,QAAQC,OAAOC,EAAIJ,EAAK,GAC7BvD,KAAKyD,QAAQC,OAAOE,EAAIL,EAAK,GAC7BvD,KAAKyD,QAAQI,OAAOF,EAAIJ,EAAK,GAAMA,EAAK,GACxCvD,KAAKyD,QAAQI,OAAOD,EAAIL,EAAK,GAAMA,EAAK,GAE1C,MAAOvD,MAAKiB,aA1FVP,KCZAoD,EAAA,WACO,QADPA,GACSnB,EAAgBxB,GJiZzB9C,gBAAgB2B,KIlZhB8D,GAEF9D,KAAK2C,eAAiBA,EACtB3C,KAAKe,YAAcI,EACnBnB,KAAK+D,eAAgB,EACrB/D,KAAKgE,SAAW,GAAItD,GAAcV,MAElCA,KAAKiE,aAAe,KACpBjE,KAAKkE,QAAU,KJudf,MAtCAzF,cIzbEqF,IJ0bAzE,IAAK,eAQL6B,MIvZQ,SAAEQ,EAAOC,GACnB,MAAO3B,MAAKgE,SAAS1B,SAAUZ,EAAOC,MJ0ZpCtC,IAAK,SACLoB,IIvbO,WAMT,MALOT,MAAKkE,UACVlE,KAAKkE,QAAUC,SAASC,cAAc,UACtCpE,KAAKkE,QAAQxC,MAAS1B,KAAKe,YAC3Bf,KAAKkE,QAAQvC,OAAS3B,KAAKe,aAEtBf,KAAKkE,WJgcV7E,IAAK,cACLoB,IIzbY,WAId,MAHOT,MAAKiE,eACVjE,KAAKiE,aAAe,GAAIjB,OAAMqB,QAASrE,KAAKkD,OAAQF,MAAMsB,YAErDtE,KAAKiE,iBAlCVH,KCcAS,EAAA,WACO,QADPA,GACSpD,GLqdT9C,gBAAgB2B,KKtdhBuE,GAOFvE,KAAKmB,KAA2B,gBAATA,IAAuB,4CAA4CqD,KAAMrD,GAAWA,EAAO,KAOlHnB,KAAKyE,aAMLzE,KAAK4C,OAAQ,ELukBb,MAxFAnE,cKngBE8F,ILogBAlF,IAAK,eACL6B,MKxeQ,SAAEC,GACZ,GAAIR,GAAW,GAAImD,GAAU9D,KAAMmB,EAKnC,OAJAnB,MAAKyE,UAAUC,KAAM/D,GAChBX,KAAK4C,OACR+B,QAAQC,IAAA,6BAAmC5E,KAAKe,YAAA,mBAAgCf,KAAKyE,UAAU3F,QAE1F6B,KLifLtB,IAAK,eAQL6B,MKveQ,SAAEQ,EAAOC,GACnB,GAAIkD,GAAO7E,IAEX,OAAS,IAAI8E,SAAS,SAAUC,EAASC,GACvC,GAAIC,GAAAC,MAIJ,IAAKxD,EAAQmD,EAAK9D,YAEhB,WADAiE,GAAQ3D,MAAA,cAAsBK,EAAA,oCAIhC,IAAKC,EAASkD,EAAK9D,YAEjB,WADAiE,GAAQ3D,MAAA,eAAuBM,EAAA,oCAiBjC,IAbOkD,EAAKJ,UAAU3F,QACpB+F,EAAKM,aAAcN,EAAK1D,MAI1B0D,EAAKJ,UAAUW,QAAS,SAAUzE,IAClB,OAATsE,GAA0BC,SAATD,KACpBA,EAAOtE,EAAS0E,aAAc3D,EAAOC,MAM3B,OAATsD,GAAmBvD,GAASmD,EAAK9D,YACtC,CAEE,GAAIJ,GAAWkE,EAAKM,aAAcN,EAAK9D,YACvCkE,GAAOtE,EAAS0E,aAAc3D,EAAOC,GAGzB,OAATsD,GAA0BC,SAATD,EACpBD,EAAQ3D,MAAA,qCAA6CK,EAAA,IAAWC,IAEhEoD,EAASE,QLgfX5F,IAAK,UACL6B,MKxeG,SAAE+D,GACFA,GACHA,EAAKK,aL4eLjG,IAAK,cACLoB,IK3iBY,WACd,MAAOT,MAAKmB,SA5CVoD,KC3BNgB,EAAAhB,CLskBE,OAAOgB","file":"three-sprite-texture-atlas-manager.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.threeSpriteAtlasTextureManager = factory()\n}(this, function () { 'use strict';\n\n  /**\n  Describes a rectangular area witin the knapsack. Abstracts the basic math away from the {@link module:texture-manager/knapsack/node|`KnapsackNode`} module.\n\n  @module texture-manager/knapsack/rectangle\n  */\n\n  /**\n   * @constructor\n   * @param {integer} left - Left most pixel index of this rectangle (0 to `right` - 1 )\n   * @param {integer} top - Top most pixel index of this rectangle (0 to `bottom` - 1 )\n   * @param {integer} right - Right most pixel index of this rectangle\n   * @param {integer} bottom - Bottom most pixel index of this rectangle\n  */\n\n  class KnapsackRectangle {\n    constructor( left, top, right, bottom ) {\n      this.left   = Math.floor( ( typeof left   === 'number' && isFinite( left   ) ) ? left   : 0 );\n      this.top    = Math.floor( ( typeof top    === 'number' && isFinite( top    ) ) ? top    : 0 );\n      this.right  = Math.floor( ( typeof right  === 'number' && isFinite( right  ) ) ? right  : 0 );\n      this.bottom = Math.floor( ( typeof bottom === 'number' && isFinite( bottom ) ) ? bottom : 0 );\n    }\n\n    /**\n     * The center X coordinate of this rectangle.\n     * @type {integer}\n     * @readonly\n     */\n    get Xcentre () { return Math.floor( ( ( this.right - this.left ) / 2 ) + this.left ) - 0.5; }\n\n    /**\n     * The center Y coordinate of this rectangle.\n     * @type {integer}\n     * @readonly\n     */\n    get Ycentre () { return Math.floor( ( ( this.bottom - this.top ) / 2 ) + this.top  ) - 0.5; }\n\n    /**\n     * The width of this rectangle in pixels.\n     * @type {integer}\n     * @readonly\n     */\n    get width ()  { return ( this.right - this.left ); }\n\n    /**\n     * The height of this rectangle in pixels.\n     * @type {integer}\n     * @readonly\n     */\n    get height () { return ( this.bottom - this.top ); }\n  }\n\n  /**\n  Represents a single rectangular area \"node\" within a texture atlas canvas, which may have its own {@link external:Texture|`THREE.Texture`} with the UV coordinates managed for you. These nodes are created through {@link module:texture-manager#allocateNode|`allocateNode()`}.\n\n  The implementation is based on [http://www.blackpawn.com/texts/lightmaps/default.html](http://www.blackpawn.com/texts/lightmaps/default.html).\n\n  @module texture-manager/knapsack/node\n  @example\n  tetureManager.allocateNode( 100, 20 ).then(\n    function( node ) {\n      // Do something with the node in this Promise, like create\n      // a sprite.\n    },\n    function( error ) {\n      // Promise was rejected\n      console.error( \"Could not allocate node:\", error );\n    }\n  );\n  */\n\n  /**\n   * @constructor\n   * @param {Knapsack} - The {@link module:texture-manager/knapsack|`Knapsack`} this node is to become a part of.\n   */\n  class KnapsackNode {\n    constructor( knapsack ) {\n      /**\n       * Reference to the {@link module:texture-manager/knapsack|`Knapsack`} this node is a part of\n       * @type {Knapsack}\n       * @private\n       * @readonly\n       */\n      this.knapsack = knapsack;\n\n      /**\n       * Optional reference to the \"left\" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.\n       * @type {KnapsackNode}\n       * @private\n       * @readonly\n       */\n      this.leftChild = null;\n\n      /**\n       * Optional reference to the \"right\" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.\n       * @type {KnapsackNode}\n       * @private\n       * @readonly\n       */\n      this.rightChild = null;\n\n      /**\n       * Describes the coordinates which are the boundaries of this node.\n       * @type {KnapsackRectangle}\n       * @private\n       * @readonly\n       */\n      this.rectangle = null;\n      // Overwritten when children are created, but done as a default here to keep\n      // the code cleaner. Instantiating this object is pretty cheap anyway.\n      this.rectangle = new KnapsackRectangle( 0, 0, knapsack.textureSize, knapsack.textureSize );\n\n      /**\n       * Internal unique ID for the image this node represents.\n       * @type {string}\n       * @readonly\n       */\n      this.imageID = null;\n\n      this._texture = null;\n    }\n\n    /**\n     * The HTML `<canvas>` element as supplied by the {@link module:texture-manager/knapsack|`Knapsack`} which this node is part of.\n     * @type {external:canvas}\n     * @readonly\n     */\n    get canvas () { return this.knapsack.canvas; }\n\n    /**\n     * Convenience accessor for the {@link external:CanvasRenderingContext2D} which is associated with the {@link module:texture-manager/knapsack/node#canvas}. You can use this context to draw on the entire canvas, but you'll probably want to use {@link module:texture-manager/knapsack/node#clipContext|`clipContext()`} instead.\n     * @type {external:CanvasRenderingContext2D}\n     * @readonly\n     */\n    get context () { return this.knapsack.canvas.getContext('2d'); }\n\n    /**\n     * The width in pixels of this sprite's texture node.\n     * @type {integer}\n     * @readonly\n     */\n    get width () { return this.rectangle.width; }\n\n    /**\n     * The height in pixels of this sprite's texture node.\n     * @type {integer}\n     * @readonly\n     */\n    get height () { return this.rectangle.height; }\n\n    /**\n     * Lazily built {@link external:Texture|`THREE.Texture`}, with it's UV coordinates already set for you. You can pass this texture straight to your material, and the GPU memory it requires should be shared with all other texture nodes on the same texture.\n     * @type {external:Texture}\n     * @readonly\n     */\n    get texture () {\n      if ( ! this._texture ) {\n        this._texture = this.knapsack.rootTexture.clone();\n        this._texture.uuid = this.knapsack.rootTexture.uuid;\n        var uvs = this.uvCoordinates();\n        this.texture.offset.x = uvs[ 0 ];\n        this.texture.offset.y = uvs[ 1 ];\n        this.texture.repeat.x = uvs[ 2 ] - uvs[ 0 ];\n        this.texture.repeat.y = uvs[ 3 ] - uvs[ 1 ];\n      }\n      return this._texture;\n    }\n\n    /**\n     * Returns true if this node has any children, which means it's not available to be drawn in. Its children may be suitable for this though.\n     * @returns {boolean}\n     * @private\n     */\n    hasChildren() {\n      return ( ( this.leftChild !== null ) || ( this.rightChild !== null ) );\n    }\n\n    /**\n     * Returns true if this node is available to be used by a texture (i.e. it's not yet been claimed by {@link module:texture-manager/knapsack/node#claim|`claim()`}.\n     * @returns {boolean} Indicates whether this node has been claimed or not.\n     * @private\n     */\n    isOccupied() {\n      return ( this.imageID !== null );\n    }\n\n    /**\n     * The UV coordinates which describe where in the texture this node is located.\n     * @returns {Array} Array with [ left, top, right, bottom ] coordinates.\n     */\n    uvCoordinates() {\n      var size = this.knapsack.textureSize;\n      return [\n            ( this.rectangle.left   / size ),\n        1 - ( this.rectangle.bottom / size ),\n            ( this.rectangle.right  / size ),\n        1 - ( this.rectangle.top    / size ),\n      ];\n    }\n\n    /**\n     * Release this node back to the {@link module:texture-manager/knapsack|`Knapsack`} where it is contained. This makes it available to be used by new sprites. Only nodes without children can be released, but a user of this library will only get these leaf nodes returned. Branch nodes are used internally only.\n     */\n    release() {\n      if ( this.hasChildren() ) {\n        throw new Error( 'Can not release tree node, still has children' );\n      }\n\n      if ( this._texture !== null ) {\n        this._texture.dispose();\n        this._texture = null;\n      }\n\n      this.clear();\n      this.imageID = null;\n\n      return;\n    }\n\n    /**\n     * Clear the area of this node: it erases the context so that it is empty and transparent, and ready to be drawn to.\n     */\n    clear() {\n      this.context.clearRect( this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1 );\n    }\n\n    /**\n     * Set the drawing context tailored towards the area of the sprite, clipping anything outside of it. Plus it sets the drawing position to the center of the node, which makes it easy to draw centered text in the node. When done drawing, use {@link module:texture-manager/knapsack/node#restoreContext|`restoreContext()`} to restore the original drawing context.\n     * @returns {CanvasRenderingContext2D} Render context configured exclusively for the sprite we're working on.\n     */\n    clipContext() {\n      var ctx = this.context;\n      ctx.save();\n      ctx.beginPath();\n      ctx.rect( this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2 );\n      ctx.clip();\n      ctx.translate( this.rectangle.Xcentre, this.rectangle.Ycentre );\n      return ctx;\n    }\n\n    /**\n     * Restore the draw context of the {@link module:texture-manager/knapsack/node#canvas|`canvas`}. Call this when done drawing the sprite.\n     */\n    restoreContext() {\n      this.context.restore();\n    }\n\n    /**\n     * Allocate a node in this {@link module:texture-manager/knapsack|`Knapsack`} for the given width and height. This is the main workhorse of this library.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {KnapsackNode} A new node which describes a rectangular area in the knapsack.\n     * @private\n     */\n    allocate( width, height ) {\n      // If we're not a leaf node\n      if ( this.hasChildren() )\n      {\n        // then try inserting into our first child\n        var newNode = this.leftChild.allocate( width, height );\n        if ( newNode instanceof KnapsackNode ) {\n          newNode.claim();\n          return newNode;\n        }\n\n        // There was no room: try to insert into second child\n        return this.rightChild.allocate( width, height );\n      }\n      else\n      {\n        // if there's already an image here, return\n        if ( this.isOccupied() ) {\n          return null;\n        }\n\n        // if this node is too small, give up here\n        if ( ( width > this.width ) || ( height > this.height ) ) {\n          return null;\n        }\n\n        // if we're just the right size, accept\n        if ( width === this.width && height === this.height ) {\n          this.claim();\n          return this;\n        }\n\n        // otherwise, got to split this node and create some kids\n        this.leftChild  = new KnapsackNode( this.knapsack );\n        this.rightChild = new KnapsackNode( this.knapsack );\n\n        // now decide which way to split\n        var remainingWidth  = this.width  - width;\n        var remainingHeight = this.height - height;\n\n        if ( remainingWidth > remainingHeight )\n        {\n          // horizontal split\n          this.leftChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top,\n            this.rectangle.left + width,\n            this.rectangle.bottom\n          );\n\n          this.rightChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left + width,\n            this.rectangle.top,\n            this.rectangle.right,\n            this.rectangle.bottom\n          );\n        }\n        else\n        {\n          // vertical split\n          this.leftChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top,\n            this.rectangle.right,\n            this.rectangle.top + height\n          );\n\n          this.rightChild.rectangle = new KnapsackRectangle(\n            this.rectangle.left,\n            this.rectangle.top + height,\n            this.rectangle.right,\n            this.rectangle.bottom\n          );\n        }\n\n        // Some crude painting to help troubleshooting\n        if ( this.knapsack.textureManager.debug ) {\n          var context = this.context;\n          context.lineWidth = 4.0;\n          context.strokeStyle = 'rgba(255,0,0,1)';\n          context.strokeRect( this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height );\n\n          context.lineWidth = 4.0;\n          context.strokeStyle = 'rgba(0,255,0,1)';\n          context.strokeRect( this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height );\n        }\n\n        // Recurse into the first child to continue the allocation\n        return this.leftChild.allocate( width, height );\n      }\n    }\n\n    /**\n     * Claim the node to be in use by giving it a (unique) ID for an image, this prevents it from being used for another image. After calling this method it is ready to be drawn.\n     * @private\n     */\n    claim() {\n      this.imageID = THREE.Math.generateUUID();\n\n      // Some crude painting to help troubleshooting\n      if ( this.knapsack.textureManager.debug ) {\n        var context = this.context;\n        context.lineWidth = 2.0;\n        context.strokeStyle = 'rgba( 0, 0, 255, 1 )';\n        context.strokeRect( this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1 );\n      }\n    }\n  }\n\n  /**\n  Represents a single texture atlas with several sprites and its corresponding base {@link external:Texture|`THREE.Texture`}. You do not interact with this class directly, it is entirely managed for you by a {@link module:texture-manager|`TextureManager`} instance. Documented only to satisfy the curiosity of fellow developers stumbling upon this.\n\n  @module texture-manager/knapsack\n   */\n\n  /**\n    * @constructor\n    * @param {TextureManager} textureManager - The {@link module:texture-manager|`TextureManager`} which created this `Knapsack`\n    * @param {integer} size - The size of the texture\n    */\n  class Knapsack {\n    constructor( textureManager, size ) {\n      this.textureManager = textureManager;\n      this.textureSize = size;\n      this.textureLoaded = false;\n      this.rootNode = new KnapsackNode( this );\n      // Lazy initialising these:\n      this._rootTexture = null;\n      this._canvas = null;\n    }\n\n    /**\n     * Lazily built HTML `<canvas>` element for this `Knapsack`.\n     * @type {external:canvas}\n     * @readonly\n     */\n    get canvas () {\n      if ( ! this._canvas ) {\n        this._canvas = document.createElement('canvas');\n        this._canvas.width  = this.textureSize;\n        this._canvas.height = this.textureSize;\n      }\n      return this._canvas;\n    }\n\n    /**\n     * Lazily built {@link external:Texture|`THREE.Texture`}, this is created as a \"master\" texture. Each node will get its own `.clone()`, which should be shared in memory.\n     * @type {external:Texture}\n     * @readonly\n     */\n    get rootTexture () {\n      if ( ! this._rootTexture ) {\n        this._rootTexture = new THREE.Texture( this.canvas, THREE.UVMapping );\n      }\n      return this._rootTexture;\n    }\n\n    /**\n     * Proxy method, allocate a texture atlas node for a sprite image of `width` by `height` pixels.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {external:Promise}\n     */\n    allocateNode( width, height ) {\n      return this.rootNode.allocate( width, height );\n    }\n  }\n\n  /**\n  Build and destroy \"nodes\" in your texture atlas easily. It builds one or more {@link module:texture-manager/knapsack|`Knapsack`} objects for you, each of which represent a separate square texture atlas with one or more sprite textures of a size defined by you.\n\n  @module texture-manager\n\n  @example\n    // ES2015 modules\n    import TextureManager from 'three-sprite-texture-atlas-manager';\n    var textureManager = new TextureManager();\n\n  @example\n    // node.js, requirejs\n    var TextureManager = require('three-sprite-texture-atlas-manager');\n    var textureManager = new TextureManager();\n\n  @example\n    // global\n    var textureManager = new window.threeSpriteAtlasTextureManager();\n   *\n   */\n\n  /**\n    * @constructor\n    * @param {integer} [size=1024] Optional size for the textures. Must be a power of two.\n    */\n  class TextureManager {\n    constructor( size ) {\n      /**\n       * The size of the textures as validated after constructing the object.\n       * @member {integer} size\n       * @readonly\n       */\n      this.size = ( ( typeof size === 'number' ) && /^(128|256|512|1024|2048|4096|8192|16384)$/.test( size ) ) ? size : 1024;\n\n      /**\n       * As the texture manager allocates nodes, it creates a new {@link module:texture-manager/knapsack|`Knapsack`} when it needs to provide space for nodes. This is an array with all the knapsacks which have been created.\n       * @member {Knapsack[]} knapsacks\n       * @readonly\n       */\n      this.knapsacks = [];\n\n      /**\n       * The debug property can be set to `true` after instantiating the object, which will make the {@link module:texture-manager/knapsack/node|`KnapsackNode`} class draw outlines as it allocates nodes. This can make it much more obvious what is going on, such as whether your text is properly sized and centered.\n       * @member {boolean} debug\n       */\n      this.debug = false;\n    }\n\n    /**\n     * Add a new knapsack to the texture manager.\n     * @param {integer} size\n     * @returns {Knapsack}\n     * @private\n     */\n    _addKnapsack( size ) {\n      var knapsack = new Knapsack( this, size );\n      this.knapsacks.push( knapsack );\n      if ( this.debug ) {\n        console.log( `TextureManager: allocated ${ this.textureSize }px texture map #${ this.knapsacks.length }` );\n      }\n      return knapsack;\n    }\n\n    /**\n     * The size of the texture\n     * @type {integer}\n     * @readonly\n     */\n    get textureSize () {\n      return this.size;\n    }\n\n    /**\n     * Allocate a texture atlas node for a sprite image of `width` by `height` pixels.\n     * @param {integer} width\n     * @param {integer} height\n     * @returns {external:Promise}\n     */\n    allocateNode( width, height ) {\n      var self = this;\n\n      return ( new Promise( function( resolve, reject ) {\n        let node;\n\n        // Prevent allocating knapsacks when there's no chance to fit the node\n        // FIXME TODO: try a bigger texture size if it doesn't fit?\n        if ( width > self.textureSize ) {\n          reject( Error( `A width of ${ width } is too large for these textures` ) );\n          return;\n        }\n\n        if ( height > self.textureSize ) {\n          reject( Error( `A height of ${ height } is too large for these textures` ) );\n          return;\n        }\n\n        if ( ! self.knapsacks.length ) {\n          self._addKnapsack( self.size );\n        }\n\n        // First try to get a node from the existing knapsacks\n        self.knapsacks.forEach( function( knapsack ) {\n          if ( node === null || node === undefined ) {\n            node = knapsack.allocateNode( width, height );\n          }\n        });\n\n        // If we didn't get a node here, but it should fit in a knapsack\n        // of the same size, so we can allocate a new knapsack\n        if ( node === null && ( width <= self.textureSize ) )\n        {\n          // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size\n          let knapsack = self._addKnapsack( self.textureSize );\n          node = knapsack.allocateNode( width, height );\n        }\n\n        if ( node === null || node === undefined ) {\n          reject( Error( `Could not allocate a node of size ${ width }x${ height }` ) );\n        } else {\n          resolve( node );\n        }\n      }));\n    }\n\n    /**\n     * Release the given node.\n     * @param {KnapsackNode} node\n     */\n    release( node ) {\n      if ( node ) {\n        node.release();\n      }\n    }\n  }\n\n\n\n  /**\n   */\n\n  /**\n  The main entry point for 'global' mode, to be used when you're not able to use `require();` or ES6 modules to load the functionality of this library. Include the library by loading the JavaScript directly, or combine it with your other code, and then do:\n\n  ```javascript\n  // Instantiate a new TextureManager with 512x512 textures\n  var textureManager = new window.threeSpriteAtlasTextureManager( 512 );\n  ```\n  * @namespace threeSpriteAtlasTextureManager\n  * @constructor\n  * @global\n  * @param {integer} [size=1024] Optional size for the textures. Must be a power of two.\n  */\n\n  var three_sprite_texture_atlas_manager = TextureManager;\n\n  return three_sprite_texture_atlas_manager;\n\n}));\n","/**\nDescribes a rectangular area witin the knapsack. Abstracts the basic math away from the {@link module:texture-manager/knapsack/node|`KnapsackNode`} module.\n\n@module texture-manager/knapsack/rectangle\n*/\n\n/**\n * @constructor\n * @param {integer} left - Left most pixel index of this rectangle (0 to `right` - 1 )\n * @param {integer} top - Top most pixel index of this rectangle (0 to `bottom` - 1 )\n * @param {integer} right - Right most pixel index of this rectangle\n * @param {integer} bottom - Bottom most pixel index of this rectangle\n*/\n\nclass KnapsackRectangle {\n  constructor( left, top, right, bottom ) {\n    this.left   = Math.floor( ( typeof left   === 'number' && isFinite( left   ) ) ? left   : 0 );\n    this.top    = Math.floor( ( typeof top    === 'number' && isFinite( top    ) ) ? top    : 0 );\n    this.right  = Math.floor( ( typeof right  === 'number' && isFinite( right  ) ) ? right  : 0 );\n    this.bottom = Math.floor( ( typeof bottom === 'number' && isFinite( bottom ) ) ? bottom : 0 );\n  }\n\n  /**\n   * The center X coordinate of this rectangle.\n   * @type {integer}\n   * @readonly\n   */\n  get Xcentre () { return Math.floor( ( ( this.right - this.left ) / 2 ) + this.left ) - 0.5; }\n\n  /**\n   * The center Y coordinate of this rectangle.\n   * @type {integer}\n   * @readonly\n   */\n  get Ycentre () { return Math.floor( ( ( this.bottom - this.top ) / 2 ) + this.top  ) - 0.5; }\n\n  /**\n   * The width of this rectangle in pixels.\n   * @type {integer}\n   * @readonly\n   */\n  get width ()  { return ( this.right - this.left ); }\n\n  /**\n   * The height of this rectangle in pixels.\n   * @type {integer}\n   * @readonly\n   */\n  get height () { return ( this.bottom - this.top ); }\n}\n\nexport default KnapsackRectangle;\n","/**\nRepresents a single rectangular area \"node\" within a texture atlas canvas, which may have its own {@link external:Texture|`THREE.Texture`} with the UV coordinates managed for you. These nodes are created through {@link module:texture-manager#allocateNode|`allocateNode()`}.\n\nThe implementation is based on [http://www.blackpawn.com/texts/lightmaps/default.html](http://www.blackpawn.com/texts/lightmaps/default.html).\n\n@module texture-manager/knapsack/node\n@example\ntetureManager.allocateNode( 100, 20 ).then(\n  function( node ) {\n    // Do something with the node in this Promise, like create\n    // a sprite.\n  },\n  function( error ) {\n    // Promise was rejected\n    console.error( \"Could not allocate node:\", error );\n  }\n);\n*/\n\nimport KnapsackRectangle from './rectangle';\n\n/**\n * @constructor\n * @param {Knapsack} - The {@link module:texture-manager/knapsack|`Knapsack`} this node is to become a part of.\n */\nclass KnapsackNode {\n  constructor( knapsack ) {\n    /**\n     * Reference to the {@link module:texture-manager/knapsack|`Knapsack`} this node is a part of\n     * @type {Knapsack}\n     * @private\n     * @readonly\n     */\n    this.knapsack = knapsack;\n\n    /**\n     * Optional reference to the \"left\" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.\n     * @type {KnapsackNode}\n     * @private\n     * @readonly\n     */\n    this.leftChild = null;\n\n    /**\n     * Optional reference to the \"right\" side {@link module:texture-manager/knapsack/node|`KnapsackNode`} branch of the tree of nodes.\n     * @type {KnapsackNode}\n     * @private\n     * @readonly\n     */\n    this.rightChild = null;\n\n    /**\n     * Describes the coordinates which are the boundaries of this node.\n     * @type {KnapsackRectangle}\n     * @private\n     * @readonly\n     */\n    this.rectangle = null;\n    // Overwritten when children are created, but done as a default here to keep\n    // the code cleaner. Instantiating this object is pretty cheap anyway.\n    this.rectangle = new KnapsackRectangle( 0, 0, knapsack.textureSize, knapsack.textureSize );\n\n    /**\n     * Internal unique ID for the image this node represents.\n     * @type {string}\n     * @readonly\n     */\n    this.imageID = null;\n\n    this._texture = null;\n  }\n\n  /**\n   * The HTML `<canvas>` element as supplied by the {@link module:texture-manager/knapsack|`Knapsack`} which this node is part of.\n   * @type {external:canvas}\n   * @readonly\n   */\n  get canvas () { return this.knapsack.canvas; }\n\n  /**\n   * Convenience accessor for the {@link external:CanvasRenderingContext2D} which is associated with the {@link module:texture-manager/knapsack/node#canvas}. You can use this context to draw on the entire canvas, but you'll probably want to use {@link module:texture-manager/knapsack/node#clipContext|`clipContext()`} instead.\n   * @type {external:CanvasRenderingContext2D}\n   * @readonly\n   */\n  get context () { return this.knapsack.canvas.getContext('2d'); }\n\n  /**\n   * The width in pixels of this sprite's texture node.\n   * @type {integer}\n   * @readonly\n   */\n  get width () { return this.rectangle.width; }\n\n  /**\n   * The height in pixels of this sprite's texture node.\n   * @type {integer}\n   * @readonly\n   */\n  get height () { return this.rectangle.height; }\n\n  /**\n   * Lazily built {@link external:Texture|`THREE.Texture`}, with it's UV coordinates already set for you. You can pass this texture straight to your material, and the GPU memory it requires should be shared with all other texture nodes on the same texture.\n   * @type {external:Texture}\n   * @readonly\n   */\n  get texture () {\n    if ( ! this._texture ) {\n      this._texture = this.knapsack.rootTexture.clone();\n      this._texture.uuid = this.knapsack.rootTexture.uuid;\n      var uvs = this.uvCoordinates();\n      this.texture.offset.x = uvs[ 0 ];\n      this.texture.offset.y = uvs[ 1 ];\n      this.texture.repeat.x = uvs[ 2 ] - uvs[ 0 ];\n      this.texture.repeat.y = uvs[ 3 ] - uvs[ 1 ];\n    }\n    return this._texture;\n  }\n\n  /**\n   * Returns true if this node has any children, which means it's not available to be drawn in. Its children may be suitable for this though.\n   * @returns {boolean}\n   * @private\n   */\n  hasChildren() {\n    return ( ( this.leftChild !== null ) || ( this.rightChild !== null ) );\n  }\n\n  /**\n   * Returns true if this node is available to be used by a texture (i.e. it's not yet been claimed by {@link module:texture-manager/knapsack/node#claim|`claim()`}.\n   * @returns {boolean} Indicates whether this node has been claimed or not.\n   * @private\n   */\n  isOccupied() {\n    return ( this.imageID !== null );\n  }\n\n  /**\n   * The UV coordinates which describe where in the texture this node is located.\n   * @returns {Array} Array with [ left, top, right, bottom ] coordinates.\n   */\n  uvCoordinates() {\n    var size = this.knapsack.textureSize;\n    return [\n          ( this.rectangle.left   / size ),\n      1 - ( this.rectangle.bottom / size ),\n          ( this.rectangle.right  / size ),\n      1 - ( this.rectangle.top    / size ),\n    ];\n  }\n\n  /**\n   * Release this node back to the {@link module:texture-manager/knapsack|`Knapsack`} where it is contained. This makes it available to be used by new sprites. Only nodes without children can be released, but a user of this library will only get these leaf nodes returned. Branch nodes are used internally only.\n   */\n  release() {\n    if ( this.hasChildren() ) {\n      throw new Error( 'Can not release tree node, still has children' );\n    }\n\n    if ( this._texture !== null ) {\n      this._texture.dispose();\n      this._texture = null;\n    }\n\n    this.clear();\n    this.imageID = null;\n\n    return;\n  }\n\n  /**\n   * Clear the area of this node: it erases the context so that it is empty and transparent, and ready to be drawn to.\n   */\n  clear() {\n    this.context.clearRect( this.rectangle.left, this.rectangle.top, this.width - 1, this.height - 1 );\n  }\n\n  /**\n   * Set the drawing context tailored towards the area of the sprite, clipping anything outside of it. Plus it sets the drawing position to the center of the node, which makes it easy to draw centered text in the node. When done drawing, use {@link module:texture-manager/knapsack/node#restoreContext|`restoreContext()`} to restore the original drawing context.\n   * @returns {CanvasRenderingContext2D} Render context configured exclusively for the sprite we're working on.\n   */\n  clipContext() {\n    var ctx = this.context;\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect( this.rectangle.left + 1, this.rectangle.top + 1, this.width - 2, this.height - 2 );\n    ctx.clip();\n    ctx.translate( this.rectangle.Xcentre, this.rectangle.Ycentre );\n    return ctx;\n  }\n\n  /**\n   * Restore the draw context of the {@link module:texture-manager/knapsack/node#canvas|`canvas`}. Call this when done drawing the sprite.\n   */\n  restoreContext() {\n    this.context.restore();\n  }\n\n  /**\n   * Allocate a node in this {@link module:texture-manager/knapsack|`Knapsack`} for the given width and height. This is the main workhorse of this library.\n   * @param {integer} width\n   * @param {integer} height\n   * @returns {KnapsackNode} A new node which describes a rectangular area in the knapsack.\n   * @private\n   */\n  allocate( width, height ) {\n    // If we're not a leaf node\n    if ( this.hasChildren() )\n    {\n      // then try inserting into our first child\n      var newNode = this.leftChild.allocate( width, height );\n      if ( newNode instanceof KnapsackNode ) {\n        newNode.claim();\n        return newNode;\n      }\n\n      // There was no room: try to insert into second child\n      return this.rightChild.allocate( width, height );\n    }\n    else\n    {\n      // if there's already an image here, return\n      if ( this.isOccupied() ) {\n        return null;\n      }\n\n      // if this node is too small, give up here\n      if ( ( width > this.width ) || ( height > this.height ) ) {\n        return null;\n      }\n\n      // if we're just the right size, accept\n      if ( width === this.width && height === this.height ) {\n        this.claim();\n        return this;\n      }\n\n      // otherwise, got to split this node and create some kids\n      this.leftChild  = new KnapsackNode( this.knapsack );\n      this.rightChild = new KnapsackNode( this.knapsack );\n\n      // now decide which way to split\n      var remainingWidth  = this.width  - width;\n      var remainingHeight = this.height - height;\n\n      if ( remainingWidth > remainingHeight )\n      {\n        // horizontal split\n        this.leftChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top,\n          this.rectangle.left + width,\n          this.rectangle.bottom\n        );\n\n        this.rightChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left + width,\n          this.rectangle.top,\n          this.rectangle.right,\n          this.rectangle.bottom\n        );\n      }\n      else\n      {\n        // vertical split\n        this.leftChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top,\n          this.rectangle.right,\n          this.rectangle.top + height\n        );\n\n        this.rightChild.rectangle = new KnapsackRectangle(\n          this.rectangle.left,\n          this.rectangle.top + height,\n          this.rectangle.right,\n          this.rectangle.bottom\n        );\n      }\n\n      // Some crude painting to help troubleshooting\n      if ( this.knapsack.textureManager.debug ) {\n        var context = this.context;\n        context.lineWidth = 4.0;\n        context.strokeStyle = 'rgba(255,0,0,1)';\n        context.strokeRect( this.leftChild.rectangle.left, this.leftChild.rectangle.top, this.leftChild.width, this.leftChild.height );\n\n        context.lineWidth = 4.0;\n        context.strokeStyle = 'rgba(0,255,0,1)';\n        context.strokeRect( this.rightChild.rectangle.left, this.rightChild.rectangle.top, this.rightChild.width, this.rightChild.height );\n      }\n\n      // Recurse into the first child to continue the allocation\n      return this.leftChild.allocate( width, height );\n    }\n  }\n\n  /**\n   * Claim the node to be in use by giving it a (unique) ID for an image, this prevents it from being used for another image. After calling this method it is ready to be drawn.\n   * @private\n   */\n  claim() {\n    this.imageID = THREE.Math.generateUUID();\n\n    // Some crude painting to help troubleshooting\n    if ( this.knapsack.textureManager.debug ) {\n      var context = this.context;\n      context.lineWidth = 2.0;\n      context.strokeStyle = 'rgba( 0, 0, 255, 1 )';\n      context.strokeRect( this.rectangle.left + 0.5, this.rectangle.top + 0.5, this.width - 1, this.height - 1 );\n    }\n  }\n}\n\nexport default KnapsackNode;\n","/**\nRepresents a single texture atlas with several sprites and its corresponding base {@link external:Texture|`THREE.Texture`}. You do not interact with this class directly, it is entirely managed for you by a {@link module:texture-manager|`TextureManager`} instance. Documented only to satisfy the curiosity of fellow developers stumbling upon this.\n\n@module texture-manager/knapsack\n */\n\nimport KnapsackNode from './knapsack/node';\n\n/**\n  * @constructor\n  * @param {TextureManager} textureManager - The {@link module:texture-manager|`TextureManager`} which created this `Knapsack`\n  * @param {integer} size - The size of the texture\n  */\nclass Knapsack {\n  constructor( textureManager, size ) {\n    this.textureManager = textureManager;\n    this.textureSize = size;\n    this.textureLoaded = false;\n    this.rootNode = new KnapsackNode( this );\n    // Lazy initialising these:\n    this._rootTexture = null;\n    this._canvas = null;\n  }\n\n  /**\n   * Lazily built HTML `<canvas>` element for this `Knapsack`.\n   * @type {external:canvas}\n   * @readonly\n   */\n  get canvas () {\n    if ( ! this._canvas ) {\n      this._canvas = document.createElement('canvas');\n      this._canvas.width  = this.textureSize;\n      this._canvas.height = this.textureSize;\n    }\n    return this._canvas;\n  }\n\n  /**\n   * Lazily built {@link external:Texture|`THREE.Texture`}, this is created as a \"master\" texture. Each node will get its own `.clone()`, which should be shared in memory.\n   * @type {external:Texture}\n   * @readonly\n   */\n  get rootTexture () {\n    if ( ! this._rootTexture ) {\n      this._rootTexture = new THREE.Texture( this.canvas, THREE.UVMapping );\n    }\n    return this._rootTexture;\n  }\n\n  /**\n   * Proxy method, allocate a texture atlas node for a sprite image of `width` by `height` pixels.\n   * @param {integer} width\n   * @param {integer} height\n   * @returns {external:Promise}\n   */\n  allocateNode( width, height ) {\n    return this.rootNode.allocate( width, height );\n  }\n}\n\nexport default Knapsack;\n","/**\nBuild and destroy \"nodes\" in your texture atlas easily. It builds one or more {@link module:texture-manager/knapsack|`Knapsack`} objects for you, each of which represent a separate square texture atlas with one or more sprite textures of a size defined by you.\n\n@module texture-manager\n\n@example\n  // ES2015 modules\n  import TextureManager from 'three-sprite-texture-atlas-manager';\n  var textureManager = new TextureManager();\n\n@example\n  // node.js, requirejs\n  var TextureManager = require('three-sprite-texture-atlas-manager');\n  var textureManager = new TextureManager();\n\n@example\n  // global\n  var textureManager = new window.threeSpriteAtlasTextureManager();\n *\n */\n\nimport Knapsack from './texture-manager/knapsack';\n\n/**\n  * @constructor\n  * @param {integer} [size=1024] Optional size for the textures. Must be a power of two.\n  */\nclass TextureManager {\n  constructor( size ) {\n    /**\n     * The size of the textures as validated after constructing the object.\n     * @member {integer} size\n     * @readonly\n     */\n    this.size = ( ( typeof size === 'number' ) && /^(128|256|512|1024|2048|4096|8192|16384)$/.test( size ) ) ? size : 1024;\n\n    /**\n     * As the texture manager allocates nodes, it creates a new {@link module:texture-manager/knapsack|`Knapsack`} when it needs to provide space for nodes. This is an array with all the knapsacks which have been created.\n     * @member {Knapsack[]} knapsacks\n     * @readonly\n     */\n    this.knapsacks = [];\n\n    /**\n     * The debug property can be set to `true` after instantiating the object, which will make the {@link module:texture-manager/knapsack/node|`KnapsackNode`} class draw outlines as it allocates nodes. This can make it much more obvious what is going on, such as whether your text is properly sized and centered.\n     * @member {boolean} debug\n     */\n    this.debug = false;\n  }\n\n  /**\n   * Add a new knapsack to the texture manager.\n   * @param {integer} size\n   * @returns {Knapsack}\n   * @private\n   */\n  _addKnapsack( size ) {\n    var knapsack = new Knapsack( this, size );\n    this.knapsacks.push( knapsack );\n    if ( this.debug ) {\n      console.log( `TextureManager: allocated ${ this.textureSize }px texture map #${ this.knapsacks.length }` );\n    }\n    return knapsack;\n  }\n\n  /**\n   * The size of the texture\n   * @type {integer}\n   * @readonly\n   */\n  get textureSize () {\n    return this.size;\n  }\n\n  /**\n   * Allocate a texture atlas node for a sprite image of `width` by `height` pixels.\n   * @param {integer} width\n   * @param {integer} height\n   * @returns {external:Promise}\n   */\n  allocateNode( width, height ) {\n    var self = this;\n\n    return ( new Promise( function( resolve, reject ) {\n      let node;\n\n      // Prevent allocating knapsacks when there's no chance to fit the node\n      // FIXME TODO: try a bigger texture size if it doesn't fit?\n      if ( width > self.textureSize ) {\n        reject( Error( `A width of ${ width } is too large for these textures` ) );\n        return;\n      }\n\n      if ( height > self.textureSize ) {\n        reject( Error( `A height of ${ height } is too large for these textures` ) );\n        return;\n      }\n\n      if ( ! self.knapsacks.length ) {\n        self._addKnapsack( self.size );\n      }\n\n      // First try to get a node from the existing knapsacks\n      self.knapsacks.forEach( function( knapsack ) {\n        if ( node === null || node === undefined ) {\n          node = knapsack.allocateNode( width, height );\n        }\n      });\n\n      // If we didn't get a node here, but it should fit in a knapsack\n      // of the same size, so we can allocate a new knapsack\n      if ( node === null && ( width <= self.textureSize ) )\n      {\n        // Didn't get a node yet but it *should* fit, so make a new texture atlas with the same size\n        let knapsack = self._addKnapsack( self.textureSize );\n        node = knapsack.allocateNode( width, height );\n      }\n\n      if ( node === null || node === undefined ) {\n        reject( Error( `Could not allocate a node of size ${ width }x${ height }` ) );\n      } else {\n        resolve( node );\n      }\n    }));\n  }\n\n  /**\n   * Release the given node.\n   * @param {KnapsackNode} node\n   */\n  release( node ) {\n    if ( node ) {\n      node.release();\n    }\n  }\n}\n\nexport default TextureManager;\n\n/**\n */\n","/**\nThe main entry point for 'global' mode, to be used when you're not able to use `require();` or ES6 modules to load the functionality of this library. Include the library by loading the JavaScript directly, or combine it with your other code, and then do:\n\n```javascript\n// Instantiate a new TextureManager with 512x512 textures\nvar textureManager = new window.threeSpriteAtlasTextureManager( 512 );\n```\n* @namespace threeSpriteAtlasTextureManager\n* @constructor\n* @global\n* @param {integer} [size=1024] Optional size for the textures. Must be a power of two.\n*/\n\nimport TextureManager from './texture-manager';\nexport default TextureManager;\n"],"sourceRoot":"/source/"}